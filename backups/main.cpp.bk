#include  "include/glad/glad.h"
#include <GLFW/glfw3.h>
#include "glm/ext/matrix_transform.hpp"
#include "glm/geometric.hpp"
// #include "glm/matrix.hpp"
#include "glm/trigonometric.hpp"
#include <iostream>
#include <cmath>
#include "shaders.h"
#include "stb_image.h"
// #include "glm/glm.hpp"
// #include "glm/gtc/matrix_transform.hpp"
#include "glm/gtc/type_ptr.hpp"

int width = 1920;
int height = 1080;

glm::vec3 cameraPos = glm::vec3(0.0f,0.0f,3.0f);
glm::vec3 cameraUp = glm::vec3(0.0f,1.0f,0.0f);
glm::vec3 cameraFront = glm::vec3(0.0f,0.0f,-1.0f);
glm::vec3 direction = glm::vec3(1.0f);

float yaw = -90.0f;
float pitch = 0.0f;

float lastX = width/2.0f;
float lastY = height/2.0f;

bool firstInput = true;

float fov = 45.0f;
 

void processInput(GLFWwindow* window);
void mouseCallBack(GLFWwindow* , double xpos , double ypos);
void scrollback(GLFWwindow* window , double xOffset , double yOffset);

int main()
{


  //Initialization
  glfwInitHint(GLFW_PLATFORM, GLFW_PLATFORM_WAYLAND);
  glfwInit();
  glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR,3); 
  glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR,3);
  glfwWindowHint(GLFW_OPENGL_PROFILE,GLFW_OPENGL_CORE_PROFILE);

  //Making a window

  GLFWwindow* window = glfwCreateWindow(height,width,"GLFW window",NULL,NULL);
  if(window == NULL){
    std::cout<<"Could not initialize window";
    glfwTerminate();
    return -1;
  }
  // glViewport(0,0,1920,1080);
  glfwMakeContextCurrent( window );
  if(!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
  {
    std::cout<<"Failed to initialize glad\n";
    return -1;
  }
  glfwSetWindowSize(window, 1920, 1080);
  glViewport(0,0,1920,1080);
  glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
  glfwSetCursorPosCallback(window, mouseCallBack);
  glfwSetScrollCallback(window , scrollback);




  //Compiling Shaders and stuff
  Shader shaders1("/home/curloz/dev/project/opengl/shaders.d/vertexShader.vert",
               "/home/curloz/dev/project/opengl/shaders.d/fragmentShader.frag");


 //wokring on our rectangle now
   
  // float vertices3[] = 
  // {
  //   0.5f,0.5f,0.5f,        1.0f,1.0f,    //top right
  //   0.5f,-0.5f,0.5f,       1.0f,0.0f,    //bottom right
  //   -0.5f,-0.5f,0.5f,      0.0f,0.0f,    //bottom left
  //   -0.5f,0.5f,0.5f,       0.0f,1.0f     //top left

    
  // };
  
  glEnable(GL_DEPTH_TEST);

  float vertices[] = {
    -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,
     0.5f, -0.5f, -0.5f,  1.0f, 0.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
    -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 0.0f,

    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
     0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 1.0f,
    -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,

    -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
    -0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
    -0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

     0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
     0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
     0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
     0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
     0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
     0.5f,  0.5f,  0.5f,  1.0f, 0.0f,

    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,
     0.5f, -0.5f, -0.5f,  1.0f, 1.0f,
     0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
     0.5f, -0.5f,  0.5f,  1.0f, 0.0f,
    -0.5f, -0.5f,  0.5f,  0.0f, 0.0f,
    -0.5f, -0.5f, -0.5f,  0.0f, 1.0f,

    // -0.5f,  0.5f, -0.5f,  0.0f, 1.0f,
     // 0.5f,  0.5f, -0.5f,  1.0f, 1.0f,
     // 0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
     // 0.5f,  0.5f,  0.5f,  1.0f, 0.0f,
    // -0.5f,  0.5f,  0.5f,  0.0f, 0.0f,
    // -0.5f,  0.5f, -0.5f,  0.0f, 1.0f
    -0.5f,  0.5f, -0.5f,  0.0f, 0.0f,  // was 0.0f, 1.0f
     0.5f,  0.5f, -0.5f,  1.0f, 0.0f,  // was 1.0f, 1.0f
     0.5f,  0.5f,  0.5f,  1.0f, 1.0f,  // was 1.0f, 0.0f
     0.5f,  0.5f,  0.5f,  1.0f, 1.0f,  // was 1.0f, 0.0f
    -0.5f,  0.5f,  0.5f,  0.0f, 1.0f,  // was 0.0f, 0.0f
    -0.5f,  0.5f, -0.5f,  0.0f, 0.0f  // was 0.0f, 1.0f
  };
  unsigned int indices[] =
  {
    0,1,3,
    1,2,3
  }; 

  // glm::mat4 trans = glm::mat4(1.0f);
  // trans = glm::rotate(trans,glm::radians(90.0f),glm::vec3(0.0f,0.0f,1.0f));
  // trans = glm::scale(trans,glm::vec3(0.5f,0.5f,0.5f));


  //Remember the order of operations on any object goes like this ->
  //1.Scale
  //2.Rotate
  //3.Translate



  unsigned int VAO,VBO,VBO2,EBO,EBO2;
  glGenVertexArrays(1,&VAO);
  glGenBuffers(1,&VBO);
  glGenBuffers(1,&VBO2);
  glGenBuffers(1,&EBO);
  glGenBuffers(1,&EBO2);

  glBindVertexArray(VAO);
  std::cout<<"Bounded VAO\n";

  glBindBuffer(GL_ARRAY_BUFFER,VBO);
  std::cout<<"Bounded VBO\n";
  glBufferData(GL_ARRAY_BUFFER,sizeof(vertices),vertices,GL_STATIC_DRAW);
  std::cout<<"Sent buffer data succesfully\n";
  // glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,EBO);
  // glBufferData(GL_ELEMENT_ARRAY_BUFFER,sizeof(indices),indices,GL_STATIC_DRAW);
 
  glVertexAttribPointer(0,3,GL_FLOAT,GL_FALSE,5*sizeof(float),(void*)0);
  glEnableVertexAttribArray(0);
  glVertexAttribPointer(1,2,GL_FLOAT,GL_FALSE,5*sizeof(float),(void*)(3*sizeof(float)));
  glEnableVertexAttribArray(1);
  
  // glVertexAttribPointer(1,3,GL_FLOAT,GL_FALSE,6*sizeof(float),(void*)(3*sizeof(float)));
  // glEnableVertexAttribArray(1);
  // glVertexAttribPointer(2,2,GL_FLOAT,GL_FALSE,6*sizeof(float),(void*)(6*sizeof(float)));
  // glEnableVertexAttribArray(2);
 
  // glBindBuffer(GL_ARRAY_BUFFER,VBO2);
  // std::cout<<"Bounded VBO\n";
  // glBufferData(GL_ARRAY_BUFFER,sizeof(vertices3),vertices3,GL_STATIC_DRAW);
  // std::cout<<"Sent buffer data succesfully\n";
  // glBindBuffer(GL_ELEMENT_ARRAY_BUFFER,EBO2);
  // glBufferData(GL_ELEMENT_ARRAY_BUFFER,sizeof(indices),indices,GL_STATIC_DRAW);
 
  // glVertexAttribPointer(5,2,GL_FLOAT,GL_FALSE,8*sizeof(float),(void*)(6*sizeof(float)));
  // glEnableVertexAttribArray(5);
  
 
  std::cout<<"Vertex Attributes enabled succesfully\n";
  glBindBuffer(GL_ARRAY_BUFFER,0);

  // glBindVertexArray(0);

  //Textures
  unsigned int texture1;
  glGenTextures(1,&texture1);
  glBindTexture(GL_TEXTURE_2D,texture1);
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
  int imageWidth,imageHeight,nrChannels;
  unsigned char *data = stbi_load("wall.jpg",&imageWidth,&imageHeight,&nrChannels,0);
 
  GLenum format;
  if (nrChannels == 1)
      format = GL_RED;
  else if (nrChannels == 3)
      format = GL_RGB;
  else if (nrChannels == 4)
      format = GL_RGBA;
  if(data)
  {
    
    glTexImage2D(GL_TEXTURE_2D,0,format,imageWidth,imageHeight,0,format,GL_UNSIGNED_BYTE,data);
    glGenerateMipmap(GL_TEXTURE_2D);
  }
  else
    
  {
    std::cout<<"Could not load texture\n";
    return -1;
  }
  std::cout<<"Generated Texture1\n";
  stbi_image_free(data);



  unsigned int texture2;
  glGenTextures(1,&texture2);
  glBindTexture(GL_TEXTURE_2D,texture2);
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,GL_REPEAT);
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
  stbi_set_flip_vertically_on_load(true);

  unsigned char *data2 = stbi_load("awesomeface.png",&width,&height,&nrChannels,0);
  if (nrChannels == 1)
      format = GL_RED;
  else if (nrChannels == 3)
      format = GL_RGB;
  else if (nrChannels == 4)
      format = GL_RGBA;

  if(data2)
  {
    glTexImage2D(GL_TEXTURE_2D,0,format,width,height,0,format,GL_UNSIGNED_BYTE,data2);
    glGenerateMipmap(GL_TEXTURE_2D);
  }
  else
  {
    std::cout<<"Could not load texture\n";
    return -1;
  }
 
  std::cout<<"Generated Texture2\n";
 
  stbi_image_free(data2);
  
  std::cout<<"Applied texture\n";

  shaders1.use();
  shaders1.setInt("texture1",0);
  glUniform1i(glGetUniformLocation(shaders1.ID,"texture2"),1);

  glm::vec3 cubePositions[] = 
  {
    glm::vec3( 0.0f,  0.0f,  0.0f),
    glm::vec3( 2.0f,  5.0f, -15.0f),
    glm::vec3(-1.5f, -2.2f, -2.5f),
    glm::vec3(-3.8f, -2.0f, -12.3f),
    glm::vec3( 2.4f, -0.4f, -3.5f),
    glm::vec3(-1.7f,  3.0f, -7.5f),
    glm::vec3( 1.3f, -2.0f, -2.5f),
    glm::vec3( 1.5f,  2.0f, -2.5f),
    glm::vec3( 1.5f,  0.2f, -1.5f),
    glm::vec3(-1.3f,  1.0f, -1.5f)
  };

  float deltaTime = 0;
  float timeTakenThisFrame = 0;
  float timeTakenLastFrame = 0;

  

  while(!glfwWindowShouldClose(window))
  {

      int width, height;
      glfwGetFramebufferSize(window, &width, &height);
      float aspectRatio = (float)width / (float)height;
      timeTakenThisFrame = glfwGetTime();
      deltaTime = timeTakenThisFrame - timeTakenLastFrame;
      timeTakenLastFrame = timeTakenThisFrame;

      processInput(window);
      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

      glClearColor(0.2f,0.3f,0.3f,1.0f);
      glClear(GL_COLOR_BUFFER_BIT);

      glActiveTexture(GL_TEXTURE0);
      glBindTexture(GL_TEXTURE_2D,texture1);
      glActiveTexture(GL_TEXTURE1);
      glBindTexture(GL_TEXTURE_2D,texture2);

      const float cameraSpeed = 2.05f * deltaTime;
      if(glfwGetKey(window,GLFW_KEY_W) == GLFW_PRESS) cameraPos += cameraSpeed * cameraFront;
      if(glfwGetKey(window,GLFW_KEY_S) == GLFW_PRESS) cameraPos -= cameraSpeed * cameraFront;
      if(glfwGetKey(window,GLFW_KEY_A) == GLFW_PRESS) cameraPos -= cameraSpeed * glm::normalize(glm::cross(cameraFront,cameraUp));
      if(glfwGetKey(window,GLFW_KEY_D) == GLFW_PRESS) cameraPos += cameraSpeed * glm::normalize(glm::cross(cameraFront,cameraUp));
      if(glfwGetKey(window,GLFW_KEY_SPACE) == GLFW_PRESS) cameraPos += cameraSpeed * cameraUp;
      if(glfwGetKey(window,GLFW_KEY_LEFT_SHIFT) == GLFW_PRESS) cameraPos -= cameraSpeed * cameraUp;

      shaders1.use();


      glm::mat4 view = glm::mat4(1.0f);
      view = glm::lookAt(cameraPos,cameraPos+cameraFront,cameraUp);
      unsigned int viewLoc = glGetUniformLocation(shaders1.ID,"view");
      glm::mat4 model ;
      glUniformMatrix4fv(viewLoc,1,GL_FALSE,glm::value_ptr(view));
      for(int i=0;i<10;++i)
      {
          model = glm::mat4(1.0f);
          model = glm::translate(model,cubePositions[i]);
          model = glm::rotate(model,(float)glfwGetTime()*(i+1)*glm::radians(50.0f),glm::vec3((i+1)*1.0f,(i+1)*2.0f,(i+1)*4.0f));

          unsigned int modelLoc = glGetUniformLocation(shaders1.ID,"model");
          glUniformMatrix4fv(modelLoc,1,GL_FALSE,glm::value_ptr(model));

          glBindVertexArray(VAO);
          glDrawArrays(GL_TRIANGLES,0,36);
      }

      model = glm::mat4(1.0f);
      glm::vec3 playerDist = cameraPos + (cameraFront*5.0f);
      model = glm::translate(model,playerDist);
      model = glm::rotate(model,glm::radians(pitch),glm::vec3(1.0f,0.0f,0.0f));
      model = glm::rotate(model,-glm::radians(yaw),glm::vec3(0.0f,1.0f,0.0f));

      unsigned int modelLoc = glGetUniformLocation(shaders1.ID,"model");
      glUniformMatrix4fv(modelLoc,1,GL_FALSE,glm::value_ptr(model));

      glBindVertexArray(VAO);
      glDrawArrays(GL_TRIANGLES,0,36);

      glm::mat4 projection = glm::mat4(1.0f);
      projection = glm::perspective(glm::radians(fov),aspectRatio,0.1f,100.0f);
      unsigned int projectionLoc = glGetUniformLocation(shaders1.ID,"projection");
      glUniformMatrix4fv(projectionLoc,1,GL_FALSE,glm::value_ptr(projection));

         //
      glfwSwapBuffers(window);
      glfwPollEvents();
    
  }
  

  glfwTerminate();
  return 0;
}


void processInput(GLFWwindow *window)
{
  if(glfwGetKey(window,GLFW_KEY_ESCAPE) == GLFW_PRESS)
  {
    glfwSetWindowShouldClose(window,true);
  }
}

void mouseCallBack( GLFWwindow* window , double xpos , double ypos )
{
  float xPos = static_cast<float>(xpos);
  float yPos = static_cast<float>(ypos);

  if(firstInput)
  {
    lastX = xPos;
    lastY = yPos;
    firstInput = false;
  }
 
  float xOffset = xPos - lastX;
  float yOffset = lastY - yPos;

  lastX = xPos;
  lastY = yPos;

  const float sensitivity = 0.05f;
  xOffset *= sensitivity;
  yOffset *= sensitivity;

  yaw += xOffset;
  pitch += yOffset;

  if(pitch >= 89.0f) 
  {
    pitch = 89.0f;
  }
  if(pitch <= -89.0f)
  {
    pitch = -89.0f;
  }

  direction.x = cos(glm::radians(yaw))*cos(glm::radians(pitch));
  direction.y = sin(glm::radians(pitch));
  direction.z = sin(glm::radians(yaw))*cos(glm::radians(pitch));

  cameraFront = glm::normalize(direction);
}

void scrollback(GLFWwindow* window , double xOffset , double yOffset)
{
  fov -= yOffset;
  if(fov <= 1) fov = 1;
  if(fov >= 90) fov = 90;
}
